/* ConstructorASTsTiny.java */
/* Generated By:JavaCC: Do not edit this line. ConstructorASTsTiny.java */
    package c_ast_descendente;
    import asint.ClaseSemanticaTiny;
    import asint.SintaxisAbstractaTiny.*;
    import c_ast_ascendente.UnidadLexica.StringLocalizado;

    public class ConstructorASTsTiny implements ConstructorASTsTinyConstants {
        private ClaseSemanticaTiny sem = new ClaseSemanticaTiny();

  final public Prog analiza() throws ParseException {
    trace_call("analiza");
    try {
Prog prog;
      prog = programa();
      jj_consume_token(0);
{if ("" != null) return prog;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("analiza");
    }
}

  final public Prog programa() throws ParseException {
    trace_call("programa");
    try {
Bloque bloque;
      bloque = bloque();
{if ("" != null) return sem.prog(bloque);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("programa");
    }
}

  final public Bloque bloque() throws ParseException {
    trace_call("bloque");
    try {
Decs decs; Instrs insts;
      jj_consume_token(llave_a);
      decs = declaraciones();
      insts = instrucciones_opt();
      jj_consume_token(llave_c);
{if ("" != null) return sem.bloque(decs, insts);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("bloque");
    }
}

  final public Decs declaraciones() throws ParseException {
    trace_call("declaraciones");
    try {
LDecs decs;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case bool:
      case real:
      case INT:
      case string:
      case struct:
      case type:
      case proc:
      case capirote:
      case iden:{
        decs = lista_declaraciones();
{if ("" != null) return sem.si_decs(decs);}
        break;
        }
      default:
        jj_la1[0] = jj_gen;
{if ("" != null) return sem.no_decs();}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("declaraciones");
    }
}

  final public LDecs lista_declaraciones() throws ParseException {
    trace_call("lista_declaraciones");
    try {
LDecs decs; Dec dec;
      dec = declaracion();
      decs = rlista_decs(sem.una_dec(dec));
      jj_consume_token(dobleampersand);
{if ("" != null) return decs;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("lista_declaraciones");
    }
}

  final public LDecs rlista_decs(LDecs decsh) throws ParseException {
    trace_call("rlista_decs");
    try {
LDecs decs; Dec dec;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case puntoycoma:{
        jj_consume_token(puntoycoma);
        dec = declaracion();
        decs = rlista_decs(sem.muchas_decs(decsh, dec));
{if ("" != null) return decs;}
        break;
        }
      default:
        jj_la1[1] = jj_gen;
{if ("" != null) return decsh;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("rlista_decs");
    }
}

  final public Dec declaracion() throws ParseException {
    trace_call("declaracion");
    try {
Dec dec;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case bool:
      case real:
      case INT:
      case string:
      case struct:
      case capirote:
      case iden:{
        dec = dec_variable();
{if ("" != null) return dec;}
        break;
        }
      case type:{
        dec = dec_tipo();
{if ("" != null) return dec;}
        break;
        }
      case proc:{
        dec = dec_procedimiento();
{if ("" != null) return dec;}
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("declaracion");
    }
}

  final public Dec dec_variable() throws ParseException {
    trace_call("dec_variable");
    try {
Tipo tipo; Token id;
      tipo = tipo();
      id = jj_consume_token(iden);
{if ("" != null) return (Dec)sem.dec_variable(tipo, id.image).ponFila(id.beginLine).ponCol(id.beginColumn);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("dec_variable");
    }
}

  final public Dec dec_tipo() throws ParseException {
    trace_call("dec_tipo");
    try {
Tipo tipo; Token id;
      jj_consume_token(type);
      tipo = tipo();
      id = jj_consume_token(iden);
{if ("" != null) return (Dec)sem.dec_tipo(tipo, id.image).ponFila(id.beginLine).ponCol(id.beginColumn);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("dec_tipo");
    }
}

  final public Dec dec_procedimiento() throws ParseException {
    trace_call("dec_procedimiento");
    try {
Token id; Params_form params_form; Bloque bloque;
      jj_consume_token(proc);
      id = jj_consume_token(iden);
      params_form = parametros_form();
      bloque = bloque();
{if ("" != null) return (Dec)sem.dec_proc(id.image, params_form, bloque).ponFila(id.beginLine).ponCol(id.beginColumn);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("dec_procedimiento");
    }
}

  final public Params_form parametros_form() throws ParseException {
    trace_call("parametros_form");
    try {
Params_form params_form;
      jj_consume_token(par_a);
      params_form = parametros_form_opt();
      jj_consume_token(par_c);
{if ("" != null) return params_form;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("parametros_form");
    }
}

  final public Params_form parametros_form_opt() throws ParseException {
    trace_call("parametros_form_opt");
    try {
LParams_form lparams;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case bool:
      case real:
      case INT:
      case string:
      case struct:
      case capirote:
      case iden:{
        lparams = parametros_form_list();
{if ("" != null) return sem.si_params_form(lparams);}
        break;
        }
      default:
        jj_la1[3] = jj_gen;
{if ("" != null) return sem.no_params_form();}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("parametros_form_opt");
    }
}

  final public LParams_form parametros_form_list() throws ParseException {
    trace_call("parametros_form_list");
    try {
Param_form param_form; LParams_form lparams_form;
      param_form = parametro_form();
      lparams_form = rparametros_form_list(sem.un_param_form(param_form));
{if ("" != null) return lparams_form;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("parametros_form_list");
    }
}

  final public LParams_form rparametros_form_list(LParams_form lparams_formh) throws ParseException {
    trace_call("rparametros_form_list");
    try {
LParams_form lparams_form; Param_form param_form;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case coma:{
        jj_consume_token(coma);
        param_form = parametro_form();
        lparams_form = rparametros_form_list(sem.muchos_params_form(lparams_formh, param_form));
{if ("" != null) return lparams_form;}
        break;
        }
      default:
        jj_la1[4] = jj_gen;
{if ("" != null) return lparams_formh;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("rparametros_form_list");
    }
}

  final public Param_form parametro_form() throws ParseException {
    trace_call("parametro_form");
    try {
Tipo tipo; Param_form param_form;
      tipo = tipo();
      param_form = ampersand_opt(tipo);
{if ("" != null) return param_form;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("parametro_form");
    }
}

  final public Param_form ampersand_opt(Tipo tipoh) throws ParseException {
    trace_call("ampersand_opt");
    try {
Token id;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ampersand:{
        jj_consume_token(ampersand);
        id = jj_consume_token(iden);
{if ("" != null) return (Param_form)sem.param_form_ref(tipoh, id.image).ponFila(id.beginLine).ponCol(id.beginColumn);}
        break;
        }
      case iden:{
        id = jj_consume_token(iden);
{if ("" != null) return (Param_form)sem.param_form_normal(tipoh, id.image).ponFila(id.beginLine).ponCol(id.beginColumn);}
        break;
        }
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ampersand_opt");
    }
}

  final public Tipo tipo() throws ParseException {
    trace_call("tipo");
    try {
Tipo tipo;
      tipo = tipo0();
{if ("" != null) return tipo;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("tipo");
    }
}

  final public Tipo tipo0() throws ParseException {
    trace_call("tipo0");
    try {
Tipo tipo1, tipo2;
      tipo1 = tipo1();
      tipo2 = RTipo0(tipo1);
{if ("" != null) return tipo2;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("tipo0");
    }
}

  final public Tipo RTipo0(Tipo tipoh) throws ParseException {
    trace_call("RTipo0");
    try {
Tipo tipo; Token num;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case corch_a:{
        jj_consume_token(corch_a);
        num = jj_consume_token(litEntero);
        jj_consume_token(corch_c);
        tipo = RTipo0((Tipo)sem.tipo_array(tipoh, num.image).ponFila(num.beginLine).ponCol(num.beginColumn));
{if ("" != null) return tipo;}
        break;
        }
      default:
        jj_la1[6] = jj_gen;
{if ("" != null) return tipoh;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("RTipo0");
    }
}

  final public Tipo tipo1() throws ParseException {
    trace_call("tipo1");
    try {
Tipo tipo;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case bool:
      case real:
      case INT:
      case string:
      case struct:
      case iden:{
        tipo = tipo2();
{if ("" != null) return tipo;}
        break;
        }
      case capirote:{
        jj_consume_token(capirote);
        tipo = tipo1();
{if ("" != null) return sem.tipo_puntero(tipo);}
        break;
        }
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("tipo1");
    }
}

  final public Tipo tipo2() throws ParseException {
    trace_call("tipo2");
    try {
Tipo tipo; Campos campos; Token id;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INT:{
        jj_consume_token(INT);
{if ("" != null) return sem.tipo_int();}
        break;
        }
      case real:{
        jj_consume_token(real);
{if ("" != null) return sem.tipo_real();}
        break;
        }
      case bool:{
        jj_consume_token(bool);
{if ("" != null) return sem.tipo_bool();}
        break;
        }
      case string:{
        jj_consume_token(string);
{if ("" != null) return sem.tipo_string();}
        break;
        }
      case struct:{
        jj_consume_token(struct);
        campos = campos();
{if ("" != null) return sem.tipo_struct(campos);}
        break;
        }
      case iden:{
        id = jj_consume_token(iden);
{if ("" != null) return (Tipo)sem.tipo_iden(id.image).ponFila(id.beginLine).ponCol(id.beginColumn);}
        break;
        }
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("tipo2");
    }
}

  final public Campos campos() throws ParseException {
    trace_call("campos");
    try {
LCampos lcampos;
      jj_consume_token(llave_a);
      lcampos = campos_lista();
      jj_consume_token(llave_c);
{if ("" != null) return sem.campos(lcampos);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("campos");
    }
}

  final public LCampos campos_lista() throws ParseException {
    trace_call("campos_lista");
    try {
LCampos lcampos; Campo campo;
      campo = campo();
      lcampos = rcampos_lista(sem.un_campo(campo));
{if ("" != null) return lcampos;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("campos_lista");
    }
}

  final public LCampos rcampos_lista(LCampos lcamposh) throws ParseException {
    trace_call("rcampos_lista");
    try {
LCampos lcampos; Campo campo;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case coma:{
        jj_consume_token(coma);
        campo = campo();
        lcampos = rcampos_lista(sem.muchos_campos(lcamposh, campo));
{if ("" != null) return lcampos;}
        break;
        }
      default:
        jj_la1[9] = jj_gen;
{if ("" != null) return lcamposh;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("rcampos_lista");
    }
}

  final public Campo campo() throws ParseException {
    trace_call("campo");
    try {
Tipo tipo; Token id;
      tipo = tipo();
      id = jj_consume_token(iden);
{if ("" != null) return (Campo)sem.campo(tipo, id.image).ponFila(id.beginLine).ponCol(id.beginColumn);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("campo");
    }
}

  final public Instrs instrucciones_opt() throws ParseException {
    trace_call("instrucciones_opt");
    try {
LInstrs insts;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IF:
      case WHILE:
      case NEW:
      case delete:
      case read:
      case write:
      case nl:
      case call:
      case llave_a:
      case arroba:{
        insts = instrucciones();
{if ("" != null) return sem.si_instrs(insts);}
        break;
        }
      default:
        jj_la1[10] = jj_gen;
{if ("" != null) return sem.no_instrs();}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("instrucciones_opt");
    }
}

  final public LInstrs instrucciones() throws ParseException {
    trace_call("instrucciones");
    try {
Instr inst; LInstrs insts;
      inst = instruccion();
      insts = rinstrucciones(sem.una_instr(inst));
{if ("" != null) return insts;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("instrucciones");
    }
}

  final public LInstrs rinstrucciones(LInstrs instsh) throws ParseException {
    trace_call("rinstrucciones");
    try {
Instr inst; LInstrs insts;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case puntoycoma:{
        jj_consume_token(puntoycoma);
        inst = instruccion();
        insts = rinstrucciones(sem.muchas_instrs(instsh, inst));
{if ("" != null) return insts;}
        break;
        }
      default:
        jj_la1[11] = jj_gen;
{if ("" != null) return instsh;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("rinstrucciones");
    }
}

  final public Instr instruccion() throws ParseException {
    trace_call("instruccion");
    try {
Instr inst;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case arroba:{
        inst = instr_eval();
{if ("" != null) return inst;}
        break;
        }
      case IF:{
        inst = instr_ifelse();
{if ("" != null) return inst;}
        break;
        }
      case WHILE:{
        inst = instr_while();
{if ("" != null) return inst;}
        break;
        }
      case read:{
        inst = instr_read();
{if ("" != null) return inst;}
        break;
        }
      case write:{
        inst = instr_write();
{if ("" != null) return inst;}
        break;
        }
      case nl:{
        inst = instr_nl();
{if ("" != null) return inst;}
        break;
        }
      case NEW:{
        inst = instr_reserva();
{if ("" != null) return inst;}
        break;
        }
      case delete:{
        inst = instr_liberacion();
{if ("" != null) return inst;}
        break;
        }
      case call:{
        inst = instr_invocacion();
{if ("" != null) return inst;}
        break;
        }
      case llave_a:{
        inst = instr_compuesta();
{if ("" != null) return inst;}
        break;
        }
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("instruccion");
    }
}

  final public Instr instr_eval() throws ParseException {
    trace_call("instr_eval");
    try {
Exp exp;
      jj_consume_token(arroba);
      exp = expresion();
{if ("" != null) return sem.eval(exp);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("instr_eval");
    }
}

  final public Instr instr_ifelse() throws ParseException {
    trace_call("instr_ifelse");
    try {
Exp exp; Bloque bloque; Instr inst;
      jj_consume_token(IF);
      exp = expresion();
      bloque = bloque();
      inst = else_opt(exp, bloque);
{if ("" != null) return inst;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("instr_ifelse");
    }
}

  final public Instr else_opt(Exp exph, Bloque bloqueh) throws ParseException {
    trace_call("else_opt");
    try {
Bloque bloque;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ELSE:{
        jj_consume_token(ELSE);
        bloque = bloque();
{if ("" != null) return sem.if_else(exph, bloqueh, bloque);}
        break;
        }
      default:
        jj_la1[13] = jj_gen;
{if ("" != null) return sem.if_(exph, bloqueh);}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("else_opt");
    }
}

  final public Instr instr_while() throws ParseException {
    trace_call("instr_while");
    try {
Exp exp; Bloque bloque;
      jj_consume_token(WHILE);
      exp = expresion();
      bloque = bloque();
{if ("" != null) return sem.while_(exp, bloque);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("instr_while");
    }
}

  final public Instr instr_read() throws ParseException {
    trace_call("instr_read");
    try {
Exp exp;
      jj_consume_token(read);
      exp = expresion();
{if ("" != null) return sem.read(exp);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("instr_read");
    }
}

  final public Instr instr_write() throws ParseException {
    trace_call("instr_write");
    try {
Exp exp;
      jj_consume_token(write);
      exp = expresion();
{if ("" != null) return sem.write(exp);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("instr_write");
    }
}

  final public Instr instr_nl() throws ParseException {
    trace_call("instr_nl");
    try {

      jj_consume_token(nl);
{if ("" != null) return sem.nl();}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("instr_nl");
    }
}

  final public Instr instr_reserva() throws ParseException {
    trace_call("instr_reserva");
    try {
Exp exp;
      jj_consume_token(NEW);
      exp = expresion();
{if ("" != null) return sem.new_(exp);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("instr_reserva");
    }
}

  final public Instr instr_liberacion() throws ParseException {
    trace_call("instr_liberacion");
    try {
Exp exp;
      jj_consume_token(delete);
      exp = expresion();
{if ("" != null) return sem.delete(exp);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("instr_liberacion");
    }
}

  final public Instr instr_compuesta() throws ParseException {
    trace_call("instr_compuesta");
    try {
Bloque bloque;
      bloque = bloque();
{if ("" != null) return sem.instr_compuesta(bloque);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("instr_compuesta");
    }
}

  final public Instr instr_invocacion() throws ParseException {
    trace_call("instr_invocacion");
    try {
Token id; Params_reales params;
      jj_consume_token(call);
      id = jj_consume_token(iden);
      params = parametros_reales();
{if ("" != null) return (Instr)sem.invoc(id.image, params).ponFila(id.beginLine).ponCol(id.beginColumn);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("instr_invocacion");
    }
}

  final public Params_reales parametros_reales() throws ParseException {
    trace_call("parametros_reales");
    try {
Params_reales params;
      jj_consume_token(par_a);
      params = parametros_reales_opt();
      jj_consume_token(par_c);
{if ("" != null) return params;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("parametros_reales");
    }
}

  final public Params_reales parametros_reales_opt() throws ParseException {
    trace_call("parametros_reales_opt");
    try {
LParams_reales lparams;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case not:
      case NULL:
      case TRUE:
      case FALSE:
      case resta:
      case par_a:
      case litEntero:
      case litReal:
      case litCadena:
      case iden:{
        lparams = parametros_reales_list();
{if ("" != null) return sem.si_params_reales(lparams);}
        break;
        }
      default:
        jj_la1[14] = jj_gen;
{if ("" != null) return sem.no_params_reales();}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("parametros_reales_opt");
    }
}

  final public LParams_reales parametros_reales_list() throws ParseException {
    trace_call("parametros_reales_list");
    try {
Exp exp; LParams_reales lparams;
      exp = expresion();
      lparams = rparametros_reales_list(sem.un_param_real(exp));
{if ("" != null) return lparams;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("parametros_reales_list");
    }
}

  final public LParams_reales rparametros_reales_list(LParams_reales lparamsh) throws ParseException {
    trace_call("rparametros_reales_list");
    try {
Exp exp; LParams_reales lparams;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case coma:{
        jj_consume_token(coma);
        exp = expresion();
        lparams = rparametros_reales_list(sem.muchos_params_reales(lparamsh, exp));
{if ("" != null) return lparams;}
        break;
        }
      default:
        jj_la1[15] = jj_gen;
{if ("" != null) return lparamsh;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("rparametros_reales_list");
    }
}

  final public Exp expresion() throws ParseException {
    trace_call("expresion");
    try {
Exp exp;
      exp = e0();
{if ("" != null) return exp;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("expresion");
    }
}

  final public Exp e0() throws ParseException {
    trace_call("e0");
    try {
Exp exp1, exp2;
      exp1 = e1();
      exp2 = re0(exp1);
{if ("" != null) return exp2;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("e0");
    }
}

  final public Exp re0(Exp exph) throws ParseException {
    trace_call("re0");
    try {
Token op; Exp exp;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case igual_op:{
        op = op0();
        exp = e0();
{if ("" != null) return (Exp)sem.mkop_desc(op.image, exph, exp).ponFila(op.beginLine).ponCol(op.beginColumn);}
        break;
        }
      default:
        jj_la1[16] = jj_gen;
{if ("" != null) return exph;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("re0");
    }
}

  final public Exp e1() throws ParseException {
    trace_call("e1");
    try {
Exp exp1, exp2;
      exp1 = e2();
      exp2 = re1(exp1);
{if ("" != null) return exp2;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("e1");
    }
}

  final public Exp re1(Exp exph) throws ParseException {
    trace_call("re1");
    try {
Token op; Exp exp1, exp2;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case menorque:
      case mayorque:
      case menorigual:
      case mayorigual:
      case igual_comp:
      case noigual_comp:{
        op = op1();
        exp1 = e2();
        exp2 = re1((Exp)sem.mkop_desc(op.image, exph, exp1).ponFila(op.beginLine).ponCol(op.beginColumn));
{if ("" != null) return exp2;}
        break;
        }
      default:
        jj_la1[17] = jj_gen;
{if ("" != null) return exph;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("re1");
    }
}

  final public Exp e2() throws ParseException {
    trace_call("e2");
    try {
Exp exp1, exp2, exp3;
      exp1 = e3();
      exp2 = re2(exp1);
      exp3 = re21(exp2);
{if ("" != null) return exp3;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("e2");
    }
}

  final public Exp re2(Exp exph) throws ParseException {
    trace_call("re2");
    try {
Exp exp; Token op;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case resta:{
        op = op2_noasoc();
        exp = e3();
{if ("" != null) return (Exp)sem.mkop_desc(op.image, exph, exp).ponFila(op.beginLine).ponCol(op.beginColumn);}
        break;
        }
      default:
        jj_la1[18] = jj_gen;
{if ("" != null) return exph;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("re2");
    }
}

  final public Exp re21(Exp exph) throws ParseException {
    trace_call("re21");
    try {
Exp exp1, exp2; Token op;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case suma:{
        op = op2_izq();
        exp1 = e3();
        exp2 = re21(exph);
{if ("" != null) return (Exp)sem.mkop_desc(op.image, exph, exp1).ponFila(op.beginLine).ponCol(op.beginColumn);}
        break;
        }
      default:
        jj_la1[19] = jj_gen;
{if ("" != null) return exph;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("re21");
    }
}

  final public Exp e3() throws ParseException {
    trace_call("e3");
    try {
Exp exp1, exp2;
      exp1 = e4();
      exp2 = re3(exp1);
{if ("" != null) return exp2;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("e3");
    }
}

  final public Exp re3(Exp exph) throws ParseException {
    trace_call("re3");
    try {
Exp exp; Token op;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case and:{
        op = op3_der();
        exp = e3();
{if ("" != null) return (Exp)sem.mkop_desc(op.image, exph, exp).ponFila(op.beginLine).ponCol(op.beginColumn);}
        break;
        }
      case or:{
        op = op3_noasoc();
        exp = e4();
{if ("" != null) return (Exp)sem.mkop_desc(op.image, exph, exp).ponFila(op.beginLine).ponCol(op.beginColumn);}
        break;
        }
      default:
        jj_la1[20] = jj_gen;
{if ("" != null) return exph;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("re3");
    }
}

  final public Exp e4() throws ParseException {
    trace_call("e4");
    try {
Exp exp1, exp2;
      exp1 = e5();
      exp2 = re4(exp1);
{if ("" != null) return exp2;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("e4");
    }
}

  final public Exp re4(Exp exph) throws ParseException {
    trace_call("re4");
    try {
Exp exp1, exp2; Token op;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case mult:
      case div:
      case porcentaje:{
        op = op4();
        exp1 = e5();
        exp2 = re4((Exp)sem.mkop_desc(op.image, exph, exp1).ponFila(op.beginLine).ponCol(op.beginColumn));
{if ("" != null) return exp2;}
        break;
        }
      default:
        jj_la1[21] = jj_gen;
{if ("" != null) return exph;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("re4");
    }
}

  final public Exp e5() throws ParseException {
    trace_call("e5");
    try {
Exp exp; Token op;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NULL:
      case TRUE:
      case FALSE:
      case par_a:
      case litEntero:
      case litReal:
      case litCadena:
      case iden:{
        exp = e6();
{if ("" != null) return exp;}
        break;
        }
      case not:
      case resta:{
        op = op5();
        exp = e5();
{if ("" != null) return (Exp)sem.mkopun_desc(op.image, exp).ponFila(op.beginLine).ponCol(op.beginColumn);}
        break;
        }
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("e5");
    }
}

  final public Exp e6() throws ParseException {
    trace_call("e6");
    try {
Exp exp1, exp2;
      exp1 = e7();
      exp2 = re6(exp1);
{if ("" != null) return exp2;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("e6");
    }
}

  final public Exp re6(Exp exph) throws ParseException {
    trace_call("re6");
    try {
Exp exp1, exp2;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case corch_a:
      case punto:
      case capirote:{
        exp1 = op6(exph);
        exp2 = re6(exp1);
{if ("" != null) return exp2;}
        break;
        }
      default:
        jj_la1[23] = jj_gen;
{if ("" != null) return exph;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("re6");
    }
}

  final public Exp e7() throws ParseException {
    trace_call("e7");
    try {
Exp exp; Token t;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case par_a:{
        jj_consume_token(par_a);
        exp = e0();
        jj_consume_token(par_c);
{if ("" != null) return exp;}
        break;
        }
      case iden:{
        t = jj_consume_token(iden);
{if ("" != null) return (Exp)sem.iden(t.image).ponFila(t.beginLine).ponCol(t.beginColumn);}
        break;
        }
      case litEntero:{
        t = jj_consume_token(litEntero);
{if ("" != null) return (Exp)sem.lit_ent(t.image).ponFila(t.beginLine).ponCol(t.beginColumn);}
        break;
        }
      case litReal:{
        t = jj_consume_token(litReal);
{if ("" != null) return (Exp)sem.lit_real(t.image).ponFila(t.beginLine).ponCol(t.beginColumn);}
        break;
        }
      case litCadena:{
        t = jj_consume_token(litCadena);
{if ("" != null) return (Exp)sem.lit_cadena(t.image).ponFila(t.beginLine).ponCol(t.beginColumn);}
        break;
        }
      case NULL:{
        t = jj_consume_token(NULL);
{if ("" != null) return (Exp)sem.null_().ponFila(t.beginLine).ponCol(t.beginColumn);}
        break;
        }
      case TRUE:{
        t = jj_consume_token(TRUE);
{if ("" != null) return (Exp)sem.true_().ponFila(t.beginLine).ponCol(t.beginColumn);}
        break;
        }
      case FALSE:{
        t = jj_consume_token(FALSE);
{if ("" != null) return (Exp)sem.false_().ponFila(t.beginLine).ponCol(t.beginColumn);}
        break;
        }
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("e7");
    }
}

  final public Token op0() throws ParseException {
    trace_call("op0");
    try {
Token t;
      t = jj_consume_token(igual_op);
{if ("" != null) return t;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("op0");
    }
}

  final public Token op1() throws ParseException {
    trace_call("op1");
    try {
Token t;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case igual_comp:{
        t = jj_consume_token(igual_comp);
{if ("" != null) return t;}
        break;
        }
      case noigual_comp:{
        t = jj_consume_token(noigual_comp);
{if ("" != null) return t;}
        break;
        }
      case menorque:{
        t = jj_consume_token(menorque);
{if ("" != null) return t;}
        break;
        }
      case mayorque:{
        t = jj_consume_token(mayorque);
{if ("" != null) return t;}
        break;
        }
      case menorigual:{
        t = jj_consume_token(menorigual);
{if ("" != null) return t;}
        break;
        }
      case mayorigual:{
        t = jj_consume_token(mayorigual);
{if ("" != null) return t;}
        break;
        }
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("op1");
    }
}

  final public Token op2_izq() throws ParseException {
    trace_call("op2_izq");
    try {
Token t;
      t = jj_consume_token(suma);
{if ("" != null) return t;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("op2_izq");
    }
}

  final public Token op2_noasoc() throws ParseException {
    trace_call("op2_noasoc");
    try {
Token t;
      t = jj_consume_token(resta);
{if ("" != null) return t;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("op2_noasoc");
    }
}

  final public Token op3_der() throws ParseException {
    trace_call("op3_der");
    try {
Token t;
      t = jj_consume_token(and);
{if ("" != null) return t;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("op3_der");
    }
}

  final public Token op3_noasoc() throws ParseException {
    trace_call("op3_noasoc");
    try {
Token t;
      t = jj_consume_token(or);
{if ("" != null) return t;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("op3_noasoc");
    }
}

  final public Token op4() throws ParseException {
    trace_call("op4");
    try {
Token t;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case mult:{
        t = jj_consume_token(mult);
{if ("" != null) return t;}
        break;
        }
      case div:{
        t = jj_consume_token(div);
{if ("" != null) return t;}
        break;
        }
      case porcentaje:{
        t = jj_consume_token(porcentaje);
{if ("" != null) return t;}
        break;
        }
      default:
        jj_la1[26] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("op4");
    }
}

  final public Token op5() throws ParseException {
    trace_call("op5");
    try {
Token t;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case resta:{
        t = jj_consume_token(resta);
{if ("" != null) return t;}
        break;
        }
      case not:{
        t = jj_consume_token(not);
{if ("" != null) return t;}
        break;
        }
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("op5");
    }
}

  final public Exp op6(Exp exph) throws ParseException {
    trace_call("op6");
    try {
Exp exp;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case corch_a:{
        exp = op_indexacion(exph);
{if ("" != null) return exp;}
        break;
        }
      case punto:{
        exp = op_acceso_registro(exph);
{if ("" != null) return exp;}
        break;
        }
      case capirote:{
        exp = op_indireccion(exph);
{if ("" != null) return exp;}
        break;
        }
      default:
        jj_la1[28] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("op6");
    }
}

  final public Exp op_indexacion(Exp exph) throws ParseException {
    trace_call("op_indexacion");
    try {
Exp exp; Token t;
      t = jj_consume_token(corch_a);
      exp = e0();
      jj_consume_token(corch_c);
{if ("" != null) return (Exp)sem.indexacion(exph, exp).ponFila(t.beginLine).ponCol(t.beginColumn);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("op_indexacion");
    }
}

  final public Exp op_acceso_registro(Exp exph) throws ParseException {
    trace_call("op_acceso_registro");
    try {
Token t;
      jj_consume_token(punto);
      t = jj_consume_token(iden);
{if ("" != null) return (Exp)sem.acceso(exph, t.image).ponFila(t.beginLine).ponCol(t.beginColumn);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("op_acceso_registro");
    }
}

  final public Exp op_indireccion(Exp exph) throws ParseException {
    trace_call("op_indireccion");
    try {
Token t;
      t = jj_consume_token(capirote);
{if ("" != null) return (Exp)sem.indireccion(exph).ponFila(t.beginLine).ponCol(t.beginColumn);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("op_indireccion");
    }
}

  /** Generated Token Manager. */
  public ConstructorASTsTinyTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[29];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
	   jj_la1_init_0();
	   jj_la1_init_1();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0x41007800,0x0,0x41007800,0x1007800,0x0,0x0,0x0,0x1007800,0x1007800,0x0,0xbea00000,0x0,0xbea00000,0x400000,0x1e0000,0x0,0x0,0x0,0x0,0x0,0x18000,0x0,0x1e0000,0x0,0x1c0000,0x0,0x0,0x20000,0x0,};
	}
	private static void jj_la1_init_1() {
	   jj_la1_1 = new int[] {0x20080001,0x4000,0x20080001,0x20080000,0x100000,0x21000000,0x10000,0x20080000,0x20000000,0x100000,0x2200000,0x4000,0x2200000,0x0,0x3c001004,0x100000,0x8000,0xfc0,0x4,0x2,0x0,0x38,0x3c001004,0xd0000,0x3c001000,0xfc0,0x38,0x4,0xd0000,};
	}

  {
      enable_tracing();
  }
  /** Constructor with InputStream. */
  public ConstructorASTsTiny(java.io.InputStream stream) {
	  this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public ConstructorASTsTiny(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source = new ConstructorASTsTinyTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 29; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 29; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public ConstructorASTsTiny(java.io.Reader stream) {
	 jj_input_stream = new SimpleCharStream(stream, 1, 1);
	 token_source = new ConstructorASTsTinyTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 29; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
	   jj_input_stream = new SimpleCharStream(stream, 1, 1);
	} else {
	   jj_input_stream.ReInit(stream, 1, 1);
	}
	if (token_source == null) {
 token_source = new ConstructorASTsTinyTokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 29; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public ConstructorASTsTiny(ConstructorASTsTinyTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 29; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(ConstructorASTsTinyTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 29; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   trace_token(token, "");
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	   trace_token(token, " (in getNextToken)");
	 return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
	 Token t = token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[62];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 29; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		   if ((jj_la1_1[i] & (1<<j)) != 0) {
			 la1tokens[32+j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 62; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  private boolean trace_enabled;

/** Trace enabled. */
  final public boolean trace_enabled() {
	 return trace_enabled;
  }

  private int trace_indent = 0;
/** Enable tracing. */
  final public void enable_tracing() {
	 trace_enabled = true;
  }

/** Disable tracing. */
  final public void disable_tracing() {
	 trace_enabled = false;
  }

  protected void trace_call(String s) {
	 if (trace_enabled) {
	   for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
	   System.out.println("Call:	" + s);
	 }
	 trace_indent = trace_indent + 2;
  }

  protected void trace_return(String s) {
	 trace_indent = trace_indent - 2;
	 if (trace_enabled) {
	   for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
	   System.out.println("Return: " + s);
	 }
  }

  protected void trace_token(Token t, String where) {
	 if (trace_enabled) {
	   for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
	   System.out.print("Consumed token: <" + tokenImage[t.kind]);
	   if (t.kind != 0 && !tokenImage[t.kind].equals("\"" + t.image + "\"")) {
		 System.out.print(": \"" + TokenMgrError.addEscapes(t.image) + "\"");
	   }
	   System.out.println(" at line " + t.beginLine + " column " + t.beginColumn + ">" + where);
	 }
  }

  protected void trace_scan(Token t1, int t2) {
	 if (trace_enabled) {
	   for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
	   System.out.print("Visited token: <" + tokenImage[t1.kind]);
	   if (t1.kind != 0 && !tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
		 System.out.print(": \"" + TokenMgrError.addEscapes(t1.image) + "\"");
	   }
	   System.out.println(" at line " + t1.beginLine + " column " + t1.beginColumn + ">; Expected token: <" + tokenImage[t2] + ">");
	 }
  }

    }
